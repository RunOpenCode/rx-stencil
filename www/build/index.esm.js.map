{"version":3,"names":["dateTimestampProvider","now","delegate","Date","undefined","ReplaySubject","Subject","constructor","_bufferSize","Infinity","_windowTime","_timestampProvider","super","this","_buffer","_infiniteTimeWindow","Math","max","next","value","isStopped","push","_trimBuffer","_subscribe","subscriber","_throwIfClosed","subscription","_innerSubscribe","copy","slice","i","length","closed","_checkFinalizedStatuses","adjustedBufferSize","splice","last","map","project","thisArg","operate","source","index","subscribe","createOperatorSubscriber","call","mergeInternals","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","active","isComplete","checkComplete","complete","outerNext","doInnerSub","innerComplete","innerFrom","innerValue","bufferedValue","shift","executeSchedule","err","error","mergeMap","resultSelector","isFunction","a","b","ii","mergeAll","identity","concatAll","concat","args","from","popScheduler","filter","predicate","share","options","connector","resetOnError","resetOnComplete","resetOnRefCountZero","wrapperSource","connection","resetConnection","subject","refCount","hasCompleted","hasErrored","cancelReset","unsubscribe","reset","resetAndUnsubscribe","conn","dest","add","handleReset","SafeSubscriber","on","onSubscriber","shareReplay","configOrBufferSize","windowTime","scheduler","bufferSize","startWith","values","takeUntil","notifier","noop","tap","observerOrNext","tapObserver","_a","isUnsub","_b","finalize","mutationObservable","target","Observable","observer","mutation","MutationObserver","mutations","observe","disconnect","renderObservable","cmp","render","Error","previousRender","Promise","resolve","then","observeSubNodes","subtree","childList","pipe","records","type","addedNodes","removedNodes","QuerySelector","selector","property","descriptor","set","get","observableProperty","shadowRoot","mutationObserver","root","getElement","observable","querySelector","distinctUntilChanged","Object","defineProperty","QuerySelectorAll","Array","querySelectorAll","previous","current","scheduleRender","nextTick","forceUpdate","toProperty","getPropertyDescriptor","disconnectObservables","WeakMap","createUsingDisconnectedCallback","previousDisconnected","disconnectedCallback","name","disconnectedSubject$","asObservable","createUsingMutationObserver","element","parentNode","forEach","record","node","delete","createDisconnectObservable","functions","fn","e","untilDisconnected","has","disconnectObservable$"],"sources":["node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js","node_modules/rxjs/dist/esm/internal/ReplaySubject.js","node_modules/rxjs/dist/esm/internal/operators/map.js","node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js","node_modules/rxjs/dist/esm/internal/operators/mergeMap.js","node_modules/rxjs/dist/esm/internal/operators/mergeAll.js","node_modules/rxjs/dist/esm/internal/operators/concatAll.js","node_modules/rxjs/dist/esm/internal/observable/concat.js","node_modules/rxjs/dist/esm/internal/operators/filter.js","node_modules/rxjs/dist/esm/internal/operators/share.js","node_modules/rxjs/dist/esm/internal/operators/shareReplay.js","node_modules/rxjs/dist/esm/internal/operators/startWith.js","node_modules/rxjs/dist/esm/internal/operators/takeUntil.js","node_modules/rxjs/dist/esm/internal/operators/tap.js","src/rx/observable/mutation-observable.ts","src/rx/observable/render-observable.ts","src/rx/decorator/query-selector.ts","src/rx/decorator/query-selector-all.ts","src/rx/operator/schedule-render.ts","src/rx/operator/to-property.ts","src/rx/operator/until-disconnected.ts"],"sourcesContent":["export const dateTimestampProvider = {\n    now() {\n        return (dateTimestampProvider.delegate || Date).now();\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=dateTimestampProvider.js.map","import { Subject } from './Subject';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\nexport class ReplaySubject extends Subject {\n    constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {\n        super();\n        this._bufferSize = _bufferSize;\n        this._windowTime = _windowTime;\n        this._timestampProvider = _timestampProvider;\n        this._buffer = [];\n        this._infiniteTimeWindow = true;\n        this._infiniteTimeWindow = _windowTime === Infinity;\n        this._bufferSize = Math.max(1, _bufferSize);\n        this._windowTime = Math.max(1, _windowTime);\n    }\n    next(value) {\n        const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n        if (!isStopped) {\n            _buffer.push(value);\n            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n        }\n        this._trimBuffer();\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        this._throwIfClosed();\n        this._trimBuffer();\n        const subscription = this._innerSubscribe(subscriber);\n        const { _infiniteTimeWindow, _buffer } = this;\n        const copy = _buffer.slice();\n        for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n            subscriber.next(copy[i]);\n        }\n        this._checkFinalizedStatuses(subscriber);\n        return subscription;\n    }\n    _trimBuffer() {\n        const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n        const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n        if (!_infiniteTimeWindow) {\n            const now = _timestampProvider.now();\n            let last = 0;\n            for (let i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {\n                last = i;\n            }\n            last && _buffer.splice(0, last + 1);\n        }\n    }\n}\n//# sourceMappingURL=ReplaySubject.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n//# sourceMappingURL=map.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    const buffer = [];\n    let active = 0;\n    let index = 0;\n    let isComplete = false;\n    const checkComplete = () => {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n    const doInnerSub = (value) => {\n        expand && subscriber.next(value);\n        active++;\n        let innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, () => {\n            innerComplete = true;\n        }, undefined, () => {\n            if (innerComplete) {\n                try {\n                    active--;\n                    while (buffer.length && active < concurrent) {\n                        const bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {\n        isComplete = true;\n        checkComplete();\n    }));\n    return () => {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n//# sourceMappingURL=mergeInternals.js.map","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent = Infinity) {\n    if (isFunction(resultSelector)) {\n        return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n//# sourceMappingURL=mergeMap.js.map","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent = Infinity) {\n    return mergeMap(identity, concurrent);\n}\n//# sourceMappingURL=mergeAll.js.map","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n//# sourceMappingURL=concatAll.js.map","import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat(...args) {\n    return concatAll()(from(args, popScheduler(args)));\n}\n//# sourceMappingURL=concat.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n//# sourceMappingURL=filter.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { operate } from '../util/lift';\nexport function share(options = {}) {\n    const { connector = () => new Subject(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n    return (wrapperSource) => {\n        let connection;\n        let resetConnection;\n        let subject;\n        let refCount = 0;\n        let hasCompleted = false;\n        let hasErrored = false;\n        const cancelReset = () => {\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n            resetConnection = undefined;\n        };\n        const reset = () => {\n            cancelReset();\n            connection = subject = undefined;\n            hasCompleted = hasErrored = false;\n        };\n        const resetAndUnsubscribe = () => {\n            const conn = connection;\n            reset();\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n        };\n        return operate((source, subscriber) => {\n            refCount++;\n            if (!hasErrored && !hasCompleted) {\n                cancelReset();\n            }\n            const dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\n            subscriber.add(() => {\n                refCount--;\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n                }\n            });\n            dest.subscribe(subscriber);\n            if (!connection &&\n                refCount > 0) {\n                connection = new SafeSubscriber({\n                    next: (value) => dest.next(value),\n                    error: (err) => {\n                        hasErrored = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnError, err);\n                        dest.error(err);\n                    },\n                    complete: () => {\n                        hasCompleted = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnComplete);\n                        dest.complete();\n                    },\n                });\n                innerFrom(source).subscribe(connection);\n            }\n        })(wrapperSource);\n    };\n}\nfunction handleReset(reset, on, ...args) {\n    if (on === true) {\n        reset();\n        return;\n    }\n    if (on === false) {\n        return;\n    }\n    const onSubscriber = new SafeSubscriber({\n        next: () => {\n            onSubscriber.unsubscribe();\n            reset();\n        },\n    });\n    return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n//# sourceMappingURL=share.js.map","import { ReplaySubject } from '../ReplaySubject';\nimport { share } from './share';\nexport function shareReplay(configOrBufferSize, windowTime, scheduler) {\n    let bufferSize;\n    let refCount = false;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\n    }\n    else {\n        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);\n    }\n    return share({\n        connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\n        resetOnError: true,\n        resetOnComplete: false,\n        resetOnRefCountZero: refCount,\n    });\n}\n//# sourceMappingURL=shareReplay.js.map","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith(...values) {\n    const scheduler = popScheduler(values);\n    return operate((source, subscriber) => {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=startWith.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\nexport function takeUntil(notifier) {\n    return operate((source, subscriber) => {\n        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=takeUntil.js.map","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    const tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error, complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate((source, subscriber) => {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            let isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, () => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, (err) => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, () => {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n//# sourceMappingURL=tap.js.map","import {\n    Observable,\n    Subscriber,\n} from 'rxjs';\n\nexport function mutationObservable(target: Node, options?: MutationObserverInit): Observable<MutationRecord[]> {\n    return new Observable((observer: Subscriber<MutationRecord[]>) => {\n        let mutation: MutationObserver = new MutationObserver((mutations: MutationRecord[]): void => {\n            observer.next(mutations);\n        });\n\n        mutation.observe(target, options);\n\n        return (): void => {\n            mutation.disconnect();\n        };\n    });\n}\n","import { ComponentInterface } from '@stencil/core';\nimport {\n    Observable,\n    Subscriber,\n    TeardownLogic,\n}                             from 'rxjs';\n\n/**\n * Returns an observable that emits when the component render()\n * function is called. Value will be emitted after the next\n * microtask (next tick).\n */\nexport function renderObservable(cmp: ComponentInterface): Observable<void> {\n    if ('function' !== typeof cmp.render) {\n        throw new Error('Component does not have a render function.');\n    }\n\n    return new Observable<void>((subscriber: Subscriber<void>): TeardownLogic => {\n        let previousRender: () => any = cmp.render;\n\n        cmp.render = function (): any {\n            Promise.resolve().then((): void => {\n                subscriber.next();\n            });\n\n            return previousRender.call(this);\n        }\n\n        return (): void => {\n            cmp.render = previousRender;\n        }\n    });\n}\n","import {\n    ComponentInterface,\n    getElement,\n} from '@stencil/core';\nimport {\n    distinctUntilChanged,\n    filter,\n    map,\n    Observable,\n    shareReplay,\n    startWith,\n} from 'rxjs';\nimport {\n    mutationObservable,\n    renderObservable,\n} from '../observable';\n\n/**\n * Options for QuerySelector decorator.\n */\nexport type QuerySelectorOptions = {\n    /**\n     * If `true`, the element will be searched in the shadow root. Default is `false`.\n     */\n    shadowRoot?: boolean;\n    /**\n     * If `true`, mutation observer instead of `renderObservable` from this package will\n     * be used to detect changes. Default is `false`.\n     */\n    mutationObserver?: boolean;\n};\n\n/**\n * Observe all sub nodes of the given node and notify\n * when any of them is removed and/or added.\n *\n * {@internal}\n */\nexport function observeSubNodes(target: Node): Observable<void> {\n    return mutationObservable(target, {\n        subtree:   true,\n        childList: true,\n    }).pipe(\n        filter((records: MutationRecord[]): boolean => {\n            for (let i: number = 0; i < records.length; i++) {\n                if ('childList' !== records[i].type) {\n                    continue;\n                }\n\n                if (records[i].addedNodes.length || records[i].removedNodes.length) {\n                    return true;\n                }\n            }\n\n            return false;\n        }),\n        map((): void => {\n            /* noop */\n        }),\n    );\n}\n\n/**\n * Property decorator inspired by Angular's @ViewChild/@ContentChild.\n *\n * After each render, the decorated property will be set to the first element\n * matching the given selector. If no element is found, the property will be\n * set to null.\n */\nexport function QuerySelector<T extends HTMLElement = HTMLElement>(selector: string, options?: QuerySelectorOptions): any {\n    return (target: Function, property: string): void => {\n        let descriptor: PropertyDescriptor = {\n            set: function (): void {\n                throw new Error(`Property \"${property}\" is read-only.`);\n            },\n            get: function (this: ComponentInterface): Observable<T | null> {\n                let observableProperty: string = `__rx__query_selector__observable__shadow_root__${options?.shadowRoot ? 'yes' : 'no'}__mutation_observer__${options?.mutationObserver ? 'yes' : 'no'}__selector__${selector}__`;\n\n                if (!this[observableProperty]) {\n                    let root: HTMLElement | ShadowRoot = options?.shadowRoot ? getElement(this).shadowRoot : getElement(this);\n                    let observable: Observable<void>   = options?.mutationObserver ? observeSubNodes(root) : renderObservable(this);\n\n                    this[observableProperty] = observable.pipe(\n                        startWith(),\n                        map((): T => root.querySelector(selector)),\n                        distinctUntilChanged(),\n                        shareReplay(1),\n                    );\n                }\n\n                return this[observableProperty];\n            },\n        }\n\n        Object.defineProperty(target, property, descriptor);\n    };\n}\n","import {\n    ComponentInterface,\n    getElement,\n}                           from '@stencil/core';\nimport {\n    distinctUntilChanged,\n    map,\n    Observable,\n    shareReplay,\n    startWith,\n}                           from 'rxjs';\nimport { renderObservable } from '../observable';\nimport { observeSubNodes }  from './query-selector';\n\n/**\n * Options for QuerySelectorAll decorator.\n */\nexport type QuerySelectorAllOptions = {\n    /**\n     * If `true`, the elements will be searched in the shadow root. Default is `false`.\n     */\n    shadowRoot?: boolean;\n    /**\n     * If `true`, mutation observer instead of `renderObservable` from this package will\n     * be used to detect changes. Default is `false`.\n     */\n    mutationObserver?: boolean;\n};\n\n/**\n * Property decorator inspired by Angular's @ViewChild/@ContentChild.\n *\n * After each render, the decorated property will be set to the first element\n * matching the given selector. If no element is found, the property will be\n * set to null.\n */\nexport function QuerySelectorAll<T extends HTMLElement = HTMLElement>(selector: string, options?: QuerySelectorAllOptions): any {\n    return (target: Function, property: string): void => {\n        let descriptor: PropertyDescriptor = {\n            set: function (): void {\n                throw new Error(`Property \"${property}\" is read-only.`);\n            },\n            get: function (this: ComponentInterface): Observable<T | null> {\n                let observableProperty: string = `__rx__query_selector_all__observable__shadow_root__${options?.shadowRoot ? 'yes' : 'no'}__mutation_observer__${options?.mutationObserver ? 'yes' : 'no'}__selector__${selector}__`;\n\n                if (!this[observableProperty]) {\n                    let root: HTMLElement | ShadowRoot = options?.shadowRoot ? getElement(this).shadowRoot : getElement(this);\n                    let observable: Observable<void>   = options?.mutationObserver ? observeSubNodes(root) : renderObservable(this);\n\n                    this[observableProperty] = observable.pipe(\n                        startWith(),\n                        map((): T[] => Array.from(root.querySelectorAll(selector))),\n                        distinctUntilChanged((previous: T[], current: T[]): boolean => {\n                            if (previous.length !== current.length) {\n                                return false;\n                            }\n\n                            for (let i: number = 0; i < previous.length; i++) {\n                                if (previous[i] !== current[i]) {\n                                    return false;\n                                }\n                            }\n\n                            return true;\n                        }),\n                        shareReplay(1),\n                    );\n                }\n\n                return this[observableProperty];\n            },\n        }\n\n        Object.defineProperty(target, property, descriptor);\n    };\n}\n","import {\n    ComponentInterface,\n    forceUpdate,\n} from '@stencil/core';\nimport {\n    MonoTypeOperatorFunction,\n    Observable,\n    tap,\n} from 'rxjs';\n\n/**\n * Schedule a render of the component. This is useful when you\n * want to force a render of the component as result of changing\n * the values of the component which are not tracked by Stencil,\n * observables, for example.\n *\n * By default, the render is scheduled on the next tick, but you\n * can disable this behavior by passing `false` as second argument.\n */\nexport function scheduleRender<T = unknown>(cmp: ComponentInterface, nextTick: boolean = true): MonoTypeOperatorFunction<T> {\n    return (source: Observable<T>): Observable<T> => {\n        return source.pipe(tap((): void => {\n            if (!nextTick) {\n                forceUpdate(cmp);\n                return;\n            }\n\n            Promise.resolve().then((): void => forceUpdate(cmp));\n        }));\n    };\n}\n","import { ComponentInterface }             from '@stencil/core';\nimport {\n    MonoTypeOperatorFunction,\n    tap,\n}                                from 'rxjs';\nimport { getPropertyDescriptor } from '../../utils';\n\n/**\n * Use this function to tap into a value stream and flush value to\n * component property. You may also use this function as subscription\n * function (function will detect that value is passed instead of\n * observable).\n */\nexport function toProperty<T = any>(cmp: ComponentInterface, property: string): MonoTypeOperatorFunction<T> {\n    // ensure that the property is defined on the component.\n    getPropertyDescriptor(cmp, property);\n\n    // @ts-ignore\n    return (source: Observable<T>): Observable<T> | void => {\n        return source.pipe(\n            tap((value: T): void => {\n                cmp[property] = value;\n            }),\n        );\n    };\n}\n","import {\n    ComponentInterface,\n    getElement,\n} from '@stencil/core';\nimport {\n    MonoTypeOperatorFunction,\n    Observable,\n    Subject,\n    Subscriber,\n    takeUntil,\n    TeardownLogic,\n} from 'rxjs';\n\n/**\n * A map of component observables that are being watched for\n * disconnect callback invocation. A weak map is being used\n * so that the component instance can be garbage collected.\n *\n * {@internal}\n */\nlet disconnectObservables: WeakMap<ComponentInterface, Observable<void>> = new WeakMap();\n\n/**\n * A function that creates an observable which emits an event\n * when the component is disconnected from DOM.\n *\n * {@internal}\n */\ntype CreateDisconnectObservableFn = (cmp: ComponentInterface) => Observable<void>;\n\n/**\n * Creates an observable that emits a value when the component\n * is disconnected from DOM and method `disconnectedCallback()`\n * is invoked. StencilJS will supress the invocation of this\n * method if it is not defined on the component.\n *\n * {@internal}\n */\nlet createUsingDisconnectedCallback: CreateDisconnectObservableFn = function (cmp: ComponentInterface): Observable<void> {\n    let previousDisconnected: Function | undefined = cmp.disconnectedCallback;\n\n    if (!previousDisconnected) {\n        throw new Error(`Component \"${cmp.constructor.name}\" does not have a \"disconnectedCallback()\" method defined.`);\n    }\n\n    let disconnectedSubject$: Subject<void> = new Subject<void>();\n\n    cmp.disconnectedCallback = function (): void {\n        if (previousDisconnected) {\n            previousDisconnected.call(cmp);\n        }\n\n        disconnectedSubject$.next();\n    };\n\n    return disconnectedSubject$.asObservable();\n}\n\n/**\n * Mutation observer is our next heuristic. We will monitor parent\n * node of the component and emit a value when the component is\n * disconnected from DOM. This will only work, of course, if the\n * component is not the root node of the application and component\n * is already within DOM.\n *\n * {@internal}\n */\nlet createUsingMutationObserver: CreateDisconnectObservableFn = function (cmp: ComponentInterface): Observable<void> {\n    let element: HTMLElement = getElement(cmp);\n\n    if (null === element.parentNode) {\n        throw new Error(`Component \"${cmp.constructor.name}\" is not within DOM.`);\n    }\n\n    return new Observable<void>((observer: Subscriber<void>): TeardownLogic => {\n\n        let mutationObserver: MutationObserver = new MutationObserver((mutations: MutationRecord[]): void => {\n            mutations.forEach((record: MutationRecord): void => {\n                for (let node of Array.from(record.removedNodes)) {\n                    if (node !== element) {\n                        continue;\n                    }\n\n                    observer.next();\n                    observer.complete();\n                }\n            });\n        });\n\n        mutationObserver.observe(element.parentNode, {\n            childList: true,\n            subtree:   true,\n        });\n\n        return (): void => {\n            mutationObserver.disconnect();\n            // we can not re-use this observable, so we have to delete it\n            disconnectObservables.delete(cmp);\n        };\n    });\n\n\n}\n\n/**\n * Creates an observable that emits a value when the component\n * is disconnected from DOM.\n *\n * {@internal}\n */\nfunction createDisconnectObservable(cmp: ComponentInterface): void {\n    let functions: CreateDisconnectObservableFn[] = [\n        createUsingDisconnectedCallback,\n        createUsingMutationObserver,\n    ];\n\n    for (let fn of functions) {\n        try {\n            disconnectObservables.set(cmp, fn(cmp));\n            return;\n        } catch (e) {\n            // noop\n        }\n    }\n\n    throw new Error(`Could not create disconnect observable for component \"${cmp.constructor.name}\".`);\n}\n\n/**\n * Operator that unsubscribes from the source observable when\n * the component is disconnected from DOM.\n */\nexport function untilDisconnected<T = unknown>(cmp: ComponentInterface): MonoTypeOperatorFunction<T> {\n    return (source: Observable<T>): Observable<T> => {\n        if (!disconnectObservables.has(cmp)) {\n            createDisconnectObservable(cmp);\n        }\n\n        let disconnectObservable$: Observable<void> = disconnectObservables.get(cmp);\n\n        return source.pipe(\n            takeUntil<T>(disconnectObservable$),\n        );\n    };\n}\n"],"mappings":"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"}