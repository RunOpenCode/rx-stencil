{"version":3,"names":["dateTimestampProvider","now","delegate","Date","undefined","ReplaySubject","Subject","constructor","_bufferSize","Infinity","_windowTime","_timestampProvider","super","this","_buffer","_infiniteTimeWindow","Math","max","next","value","isStopped","push","_trimBuffer","_subscribe","subscriber","_throwIfClosed","subscription","_innerSubscribe","copy","slice","i","length","closed","_checkFinalizedStatuses","adjustedBufferSize","splice","last","map","project","thisArg","operate","source","index","subscribe","createOperatorSubscriber","call","mergeInternals","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","active","isComplete","checkComplete","complete","outerNext","doInnerSub","innerComplete","innerFrom","innerValue","bufferedValue","shift","executeSchedule","err","error","mergeMap","resultSelector","isFunction","a","b","ii","mergeAll","identity","concatAll","concat","args","from","popScheduler","share","options","connector","resetOnError","resetOnComplete","resetOnRefCountZero","wrapperSource","connection","resetConnection","subject","refCount","hasCompleted","hasErrored","cancelReset","unsubscribe","reset","resetAndUnsubscribe","conn","dest","add","handleReset","SafeSubscriber","on","onSubscriber","shareReplay","configOrBufferSize","windowTime","scheduler","bufferSize","startWith","values","takeUntil","notifier","noop","tap","observerOrNext","tapObserver","_a","isUnsub","_b","finalize","renderObservable","cmp","render","Error","Observable","previousRender","Promise","resolve","then","QuerySelector","selector","shadowRoot","target","property","descriptor","set","get","observableProperty","root","getElement","pipe","querySelector","distinctUntilChanged","Object","defineProperty","QuerySelectorAll","Array","querySelectorAll","previous","current","scheduleRender","nextTick","forceUpdate","toProperty","getPropertyDescriptor","disconnectObservables","WeakMap","createUsingDisconnectedCallback","previousDisconnected","disconnectedCallback","name","disconnectedSubject$","asObservable","createUsingMutationObserver","element","parentNode","observer","mutationObserver","MutationObserver","mutations","forEach","record","node","removedNodes","observe","childList","subtree","disconnect","delete","createDisconnectObservable","functions","fn","e","untilDisconnected","has","disconnectObservable$"],"sources":["node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js","node_modules/rxjs/dist/esm/internal/ReplaySubject.js","node_modules/rxjs/dist/esm/internal/operators/map.js","node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js","node_modules/rxjs/dist/esm/internal/operators/mergeMap.js","node_modules/rxjs/dist/esm/internal/operators/mergeAll.js","node_modules/rxjs/dist/esm/internal/operators/concatAll.js","node_modules/rxjs/dist/esm/internal/observable/concat.js","node_modules/rxjs/dist/esm/internal/operators/share.js","node_modules/rxjs/dist/esm/internal/operators/shareReplay.js","node_modules/rxjs/dist/esm/internal/operators/startWith.js","node_modules/rxjs/dist/esm/internal/operators/takeUntil.js","node_modules/rxjs/dist/esm/internal/operators/tap.js","src/rx/observable/render-observable.ts","src/rx/decorator/query-selector.ts","src/rx/decorator/query-selector-all.ts","src/rx/operator/schedule-render.ts","src/rx/operator/to-property.ts","src/rx/operator/until-disconnected.ts"],"sourcesContent":["export const dateTimestampProvider = {\n    now() {\n        return (dateTimestampProvider.delegate || Date).now();\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=dateTimestampProvider.js.map","import { Subject } from './Subject';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\nexport class ReplaySubject extends Subject {\n    constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {\n        super();\n        this._bufferSize = _bufferSize;\n        this._windowTime = _windowTime;\n        this._timestampProvider = _timestampProvider;\n        this._buffer = [];\n        this._infiniteTimeWindow = true;\n        this._infiniteTimeWindow = _windowTime === Infinity;\n        this._bufferSize = Math.max(1, _bufferSize);\n        this._windowTime = Math.max(1, _windowTime);\n    }\n    next(value) {\n        const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n        if (!isStopped) {\n            _buffer.push(value);\n            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n        }\n        this._trimBuffer();\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        this._throwIfClosed();\n        this._trimBuffer();\n        const subscription = this._innerSubscribe(subscriber);\n        const { _infiniteTimeWindow, _buffer } = this;\n        const copy = _buffer.slice();\n        for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n            subscriber.next(copy[i]);\n        }\n        this._checkFinalizedStatuses(subscriber);\n        return subscription;\n    }\n    _trimBuffer() {\n        const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n        const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n        if (!_infiniteTimeWindow) {\n            const now = _timestampProvider.now();\n            let last = 0;\n            for (let i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {\n                last = i;\n            }\n            last && _buffer.splice(0, last + 1);\n        }\n    }\n}\n//# sourceMappingURL=ReplaySubject.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n//# sourceMappingURL=map.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    const buffer = [];\n    let active = 0;\n    let index = 0;\n    let isComplete = false;\n    const checkComplete = () => {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n    const doInnerSub = (value) => {\n        expand && subscriber.next(value);\n        active++;\n        let innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, () => {\n            innerComplete = true;\n        }, undefined, () => {\n            if (innerComplete) {\n                try {\n                    active--;\n                    while (buffer.length && active < concurrent) {\n                        const bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {\n        isComplete = true;\n        checkComplete();\n    }));\n    return () => {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n//# sourceMappingURL=mergeInternals.js.map","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent = Infinity) {\n    if (isFunction(resultSelector)) {\n        return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n//# sourceMappingURL=mergeMap.js.map","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent = Infinity) {\n    return mergeMap(identity, concurrent);\n}\n//# sourceMappingURL=mergeAll.js.map","import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n//# sourceMappingURL=concatAll.js.map","import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat(...args) {\n    return concatAll()(from(args, popScheduler(args)));\n}\n//# sourceMappingURL=concat.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { operate } from '../util/lift';\nexport function share(options = {}) {\n    const { connector = () => new Subject(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n    return (wrapperSource) => {\n        let connection;\n        let resetConnection;\n        let subject;\n        let refCount = 0;\n        let hasCompleted = false;\n        let hasErrored = false;\n        const cancelReset = () => {\n            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n            resetConnection = undefined;\n        };\n        const reset = () => {\n            cancelReset();\n            connection = subject = undefined;\n            hasCompleted = hasErrored = false;\n        };\n        const resetAndUnsubscribe = () => {\n            const conn = connection;\n            reset();\n            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n        };\n        return operate((source, subscriber) => {\n            refCount++;\n            if (!hasErrored && !hasCompleted) {\n                cancelReset();\n            }\n            const dest = (subject = subject !== null && subject !== void 0 ? subject : connector());\n            subscriber.add(() => {\n                refCount--;\n                if (refCount === 0 && !hasErrored && !hasCompleted) {\n                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n                }\n            });\n            dest.subscribe(subscriber);\n            if (!connection &&\n                refCount > 0) {\n                connection = new SafeSubscriber({\n                    next: (value) => dest.next(value),\n                    error: (err) => {\n                        hasErrored = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnError, err);\n                        dest.error(err);\n                    },\n                    complete: () => {\n                        hasCompleted = true;\n                        cancelReset();\n                        resetConnection = handleReset(reset, resetOnComplete);\n                        dest.complete();\n                    },\n                });\n                innerFrom(source).subscribe(connection);\n            }\n        })(wrapperSource);\n    };\n}\nfunction handleReset(reset, on, ...args) {\n    if (on === true) {\n        reset();\n        return;\n    }\n    if (on === false) {\n        return;\n    }\n    const onSubscriber = new SafeSubscriber({\n        next: () => {\n            onSubscriber.unsubscribe();\n            reset();\n        },\n    });\n    return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n//# sourceMappingURL=share.js.map","import { ReplaySubject } from '../ReplaySubject';\nimport { share } from './share';\nexport function shareReplay(configOrBufferSize, windowTime, scheduler) {\n    let bufferSize;\n    let refCount = false;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\n    }\n    else {\n        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);\n    }\n    return share({\n        connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\n        resetOnError: true,\n        resetOnComplete: false,\n        resetOnRefCountZero: refCount,\n    });\n}\n//# sourceMappingURL=shareReplay.js.map","import { concat } from '../observable/concat';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\nexport function startWith(...values) {\n    const scheduler = popScheduler(values);\n    return operate((source, subscriber) => {\n        (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=startWith.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\nexport function takeUntil(notifier) {\n    return operate((source, subscriber) => {\n        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=takeUntil.js.map","import { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nexport function tap(observerOrNext, error, complete) {\n    const tapObserver = isFunction(observerOrNext) || error || complete\n        ?\n            { next: observerOrNext, error, complete }\n        : observerOrNext;\n    return tapObserver\n        ? operate((source, subscriber) => {\n            var _a;\n            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n            let isUnsub = true;\n            source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n                var _a;\n                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);\n                subscriber.next(value);\n            }, () => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                subscriber.complete();\n            }, (err) => {\n                var _a;\n                isUnsub = false;\n                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);\n                subscriber.error(err);\n            }, () => {\n                var _a, _b;\n                if (isUnsub) {\n                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n                }\n                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n            }));\n        })\n        :\n            identity;\n}\n//# sourceMappingURL=tap.js.map","import { ComponentInterface } from '@stencil/core';\nimport {\n    Observable,\n    Subscriber,\n    TeardownLogic,\n}                             from 'rxjs';\n\n/**\n * Returns an observable that emits when the component render()\n * function is called. Value will be emitted after the next\n * microtask (next tick).\n */\nexport function renderObservable(cmp: ComponentInterface): Observable<void> {\n    if ('function' !== typeof cmp.render) {\n        throw new Error('Component does not have a render function.');\n    }\n\n    return new Observable<void>((subscriber: Subscriber<void>): TeardownLogic => {\n        let previousRender: () => any = cmp.render;\n\n        cmp.render = function (): any {\n            Promise.resolve().then((): void => {\n                subscriber.next();\n            });\n\n            return previousRender.call(this);\n        }\n\n        return (): void => {\n            cmp.render = previousRender;\n        }\n    });\n}\n","import {\n    ComponentInterface,\n    getElement,\n}                           from '@stencil/core';\nimport {\n    distinctUntilChanged,\n    map,\n    Observable,\n    shareReplay,\n    startWith,\n}                           from 'rxjs';\nimport { renderObservable } from '../observable';\n\n/**\n * Property decorator inspired by Angular's @ViewChild/@ContentChild.\n *\n * After each render, the decorated property will be set to the first element\n * matching the given selector. If no element is found, the property will be\n * set to null.\n */\nexport function QuerySelector<T extends HTMLElement = HTMLElement>(selector: string, shadowRoot: boolean = false): any {\n    return (target: Function, property: string): void => {\n        let descriptor: PropertyDescriptor = {\n            set: function (): void {\n                throw new Error(`Property \"${property}\" is read-only.`);\n            },\n            get: function (this: ComponentInterface): Observable<T | null> {\n                let observableProperty: string = `__rx__query_selector__observable__shadow_root__${shadowRoot ? 'yes' : 'no'}__selector__${selector}__`;\n\n                if (!this[observableProperty]) {\n                    let root: HTMLElement | ShadowRoot = getElement(this);\n\n                    if (shadowRoot) {\n                        root = root.shadowRoot;\n                    }\n\n                    this[observableProperty] = renderObservable(this).pipe(\n                        map((): T => root.querySelector(selector)),\n                        startWith(null),\n                        distinctUntilChanged(),\n                        shareReplay(1),\n                    );\n                }\n\n                return this[observableProperty];\n            },\n        }\n\n        Object.defineProperty(target, property, descriptor);\n    };\n}\n","import {\n    ComponentInterface,\n    getElement,\n}                           from '@stencil/core';\nimport {\n    distinctUntilChanged,\n    map,\n    Observable,\n    shareReplay,\n    startWith,\n}                           from 'rxjs';\nimport { renderObservable } from '../observable';\n\n/**\n * Property decorator inspired by Angular's @ViewChild/@ContentChild.\n *\n * After each render, the decorated property will be set to the first element\n * matching the given selector. If no element is found, the property will be\n * set to null.\n */\nexport function QuerySelectorAll<T extends HTMLElement = HTMLElement>(selector: string, shadowRoot: boolean = false): any {\n    return (target: Function, property: string): void => {\n        let descriptor: PropertyDescriptor = {\n            set: function (): void {\n                throw new Error(`Property \"${property}\" is read-only.`);\n            },\n            get: function (this: ComponentInterface): Observable<T | null> {\n                let observableProperty: string = `__rx__query_selector_all__observable__shadow_root__${shadowRoot ? 'yes' : 'no'}__selector__${selector}__`;\n\n                if (!this[observableProperty]) {\n                    let root: HTMLElement | ShadowRoot = getElement(this);\n\n                    if (shadowRoot) {\n                        root = root.shadowRoot;\n                    }\n\n                    this[observableProperty] = renderObservable(this).pipe(\n                        map((): T[] => Array.from(root.querySelectorAll(selector))),\n                        startWith([]),\n                        distinctUntilChanged((previous: T[], current: T[]): boolean => {\n                            if (previous.length !== current.length) {\n                                return false;\n                            }\n                            \n                            for (let i: number = 0; i < previous.length; i++) {\n                                if (previous[i] !== current[i]) {\n                                    return false;\n                                }\n                            }\n                            \n                            return true;\n                        }),\n                        shareReplay(1),\n                    );\n                }\n\n                return this[observableProperty];\n            },\n        }\n\n        Object.defineProperty(target, property, descriptor);\n    };\n}\n","import {\n    ComponentInterface,\n    forceUpdate,\n} from '@stencil/core';\nimport {\n    MonoTypeOperatorFunction,\n    Observable,\n    tap,\n} from 'rxjs';\n\n/**\n * Schedule a render of the component. This is useful when you\n * want to force a render of the component as result of changing\n * the values of the component which are not tracked by Stencil,\n * observables, for example.\n *\n * By default, the render is scheduled on the next tick, but you\n * can disable this behavior by passing `false` as second argument.\n */\nexport function scheduleRender<T = unknown>(cmp: ComponentInterface, nextTick: boolean = true): MonoTypeOperatorFunction<T> {\n    return (source: Observable<T>): Observable<T> => {\n        return source.pipe(tap((): void => {\n            if (!nextTick) {\n                forceUpdate(cmp);\n                return;\n            }\n\n            Promise.resolve().then((): void => forceUpdate(cmp));\n        }));\n    };\n}\n","import { ComponentInterface }             from '@stencil/core';\nimport {\n    MonoTypeOperatorFunction,\n    tap,\n}                                from 'rxjs';\nimport { getPropertyDescriptor } from '../../utils';\n\n/**\n * Use this function to tap into a value stream and flush value to\n * component property. You may also use this function as subscription\n * function (function will detect that value is passed instead of\n * observable).\n */\nexport function toProperty<T = any>(cmp: ComponentInterface, property: string): MonoTypeOperatorFunction<T> {\n    // ensure that the property is defined on the component.\n    getPropertyDescriptor(cmp, property);\n\n    // @ts-ignore\n    return (source: Observable<T>): Observable<T> | void => {\n        return source.pipe(\n            tap((value: T): void => {\n                cmp[property] = value;\n            }),\n        );\n    };\n}\n","import {\n    ComponentInterface,\n    getElement,\n} from '@stencil/core';\nimport {\n    MonoTypeOperatorFunction,\n    Observable,\n    Subject,\n    Subscriber,\n    takeUntil,\n    TeardownLogic,\n} from 'rxjs';\n\n/**\n * A map of component observables that are being watched for\n * disconnect callback invocation. A weak map is being used\n * so that the component instance can be garbage collected.\n *\n * {@internal}\n */\nlet disconnectObservables: WeakMap<ComponentInterface, Observable<void>> = new WeakMap();\n\n/**\n * A function that creates an observable which emits an event\n * when the component is disconnected from DOM.\n *\n * {@internal}\n */\ntype CreateDisconnectObservableFn = (cmp: ComponentInterface) => Observable<void>;\n\n/**\n * Creates an observable that emits a value when the component\n * is disconnected from DOM and method `disconnectedCallback()`\n * is invoked. StencilJS will supress the invocation of this\n * method if it is not defined on the component.\n *\n * {@internal}\n */\nlet createUsingDisconnectedCallback: CreateDisconnectObservableFn = function (cmp: ComponentInterface): Observable<void> {\n    let previousDisconnected: Function | undefined = cmp.disconnectedCallback;\n\n    if (!previousDisconnected) {\n        throw new Error(`Component \"${cmp.constructor.name}\" does not have a \"disconnectedCallback()\" method defined.`);\n    }\n\n    let disconnectedSubject$: Subject<void> = new Subject<void>();\n\n    cmp.disconnectedCallback = function (): void {\n        if (previousDisconnected) {\n            previousDisconnected.call(cmp);\n        }\n\n        disconnectedSubject$.next();\n    };\n\n    return disconnectedSubject$.asObservable();\n}\n\n/**\n * Mutation observer is our next heuristic. We will monitor parent\n * node of the component and emit a value when the component is\n * disconnected from DOM. This will only work, of course, if the\n * component is not the root node of the application and component\n * is already within DOM.\n *\n * {@internal}\n */\nlet createUsingMutationObserver: CreateDisconnectObservableFn = function (cmp: ComponentInterface): Observable<void> {\n    let element: HTMLElement = getElement(cmp);\n\n    if (null === element.parentNode) {\n        throw new Error(`Component \"${cmp.constructor.name}\" is not within DOM.`);\n    }\n\n    return new Observable<void>((observer: Subscriber<void>): TeardownLogic => {\n\n        let mutationObserver: MutationObserver = new MutationObserver((mutations: MutationRecord[]): void => {\n            mutations.forEach((record: MutationRecord): void => {\n                for (let node of Array.from(record.removedNodes)) {\n                    if (node !== element) {\n                        continue;\n                    }\n\n                    observer.next();\n                    observer.complete();\n                }\n            });\n        });\n\n        mutationObserver.observe(element.parentNode, {\n            childList: true,\n            subtree:   true,\n        });\n\n        return (): void => {\n            mutationObserver.disconnect();\n            // we can not re-use this observable, so we have to delete it\n            disconnectObservables.delete(cmp);\n        };\n    });\n\n\n}\n\n/**\n * Creates an observable that emits a value when the component\n * is disconnected from DOM.\n *\n * {@internal}\n */\nfunction createDisconnectObservable(cmp: ComponentInterface): void {\n    let functions: CreateDisconnectObservableFn[] = [\n        createUsingDisconnectedCallback,\n        createUsingMutationObserver,\n    ];\n\n    for (let fn of functions) {\n        try {\n            disconnectObservables.set(cmp, fn(cmp));\n            return;\n        } catch (e) {\n            // noop\n        }\n    }\n\n    throw new Error(`Could not create disconnect observable for component \"${cmp.constructor.name}\".`);\n}\n\n/**\n * Operator that unsubscribes from the source observable when\n * the component is disconnected from DOM.\n */\nexport function untilDisconnected<T = unknown>(cmp: ComponentInterface): MonoTypeOperatorFunction<T> {\n    return (source: Observable<T>): Observable<T> => {\n        if (!disconnectObservables.has(cmp)) {\n            createDisconnectObservable(cmp);\n        }\n\n        let disconnectObservable$: Observable<void> = disconnectObservables.get(cmp);\n\n        return source.pipe(\n            takeUntil<T>(disconnectObservable$),\n        );\n    };\n}\n"],"mappings":"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"}