{"version":3,"file":"query-selector.js","sourceRoot":"","sources":["../../../src/rx/decorator/query-selector.ts"],"names":[],"mappings":"AAAA,OAAO,EAEH,UAAU,GACb,MAAgC,eAAe,CAAC;AACjD,OAAO,EACH,oBAAoB,EACpB,GAAG,EAEH,WAAW,EACX,SAAS,GACZ,MAAgC,MAAM,CAAC;AACxC,OAAO,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAEjD;;;;;;GAMG;AACH,MAAM,UAAU,aAAa,CAAsC,QAAgB,EAAE,aAAsB,KAAK;EAC5G,OAAO,CAAC,MAAgB,EAAE,QAAgB,EAAQ,EAAE;IAChD,IAAI,UAAU,GAAuB;MACjC,GAAG,EAAE;QACD,MAAM,IAAI,KAAK,CAAC,aAAa,QAAQ,iBAAiB,CAAC,CAAC;MAC5D,CAAC;MACD,GAAG,EAAE;QACD,IAAI,kBAAkB,GAAW,kDAAkD,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,eAAe,QAAQ,IAAI,CAAC;QAExI,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE;UAC3B,IAAI,IAAI,GAA6B,UAAU,CAAC,IAAI,CAAC,CAAC;UAEtD,IAAI,UAAU,EAAE;YACZ,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;WAC1B;UAED,IAAI,CAAC,kBAAkB,CAAC,GAAG,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,CAClD,SAAS,EAAE,EACX,GAAG,CAAC,GAAM,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,EAC1C,oBAAoB,EAAE,EACtB,WAAW,CAAC,CAAC,CAAC,CACjB,CAAC;SACL;QAED,OAAO,IAAI,CAAC,kBAAkB,CAAC,CAAC;MACpC,CAAC;KACJ,CAAA;IAED,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;EACxD,CAAC,CAAC;AACN,CAAC","sourcesContent":["import {\n    ComponentInterface,\n    getElement,\n}                           from '@stencil/core';\nimport {\n    distinctUntilChanged,\n    map,\n    Observable,\n    shareReplay,\n    startWith,\n}                           from 'rxjs';\nimport { renderObservable } from '../observable';\n\n/**\n * Property decorator inspired by Angular's @ViewChild/@ContentChild.\n *\n * After each render, the decorated property will be set to the first element\n * matching the given selector. If no element is found, the property will be\n * set to null.\n */\nexport function QuerySelector<T extends HTMLElement = HTMLElement>(selector: string, shadowRoot: boolean = false): any {\n    return (target: Function, property: string): void => {\n        let descriptor: PropertyDescriptor = {\n            set: function (): void {\n                throw new Error(`Property \"${property}\" is read-only.`);\n            },\n            get: function (this: ComponentInterface): Observable<T | null> {\n                let observableProperty: string = `__rx__query_selector__observable__shadow_root__${shadowRoot ? 'yes' : 'no'}__selector__${selector}__`;\n\n                if (!this[observableProperty]) {\n                    let root: HTMLElement | ShadowRoot = getElement(this);\n\n                    if (shadowRoot) {\n                        root = root.shadowRoot;\n                    }\n\n                    this[observableProperty] = renderObservable(this).pipe(\n                        startWith(),\n                        map((): T => root.querySelector(selector)),\n                        distinctUntilChanged(),\n                        shareReplay(1),\n                    );\n                }\n\n                return this[observableProperty];\n            },\n        }\n\n        Object.defineProperty(target, property, descriptor);\n    };\n}\n"]}